# Описание алгоритма
Для начала построим суффиксный автомат на данной строке. Теперь для ответа на запрос будем брать паттерн и делить его на подстроки, не содержащие "?". Для каждой такой подстроки найдём все её вхождения в исходную строку, тогда ответом будет пересечение множеств вхождений по всем строкам (как это сделать оптимально будет описано позже)

# Оптимизации
Самая главная (да и по сути единственная неочевидная) оптимизация заключается в правильном расчёте вхождений подстрок. Заведём для каждого индекса счётчик числа подстрок, для которых этот индекс подходит в качестве индекса начала вхождения паттерна, тогда ответам будут являться те индексы, для которых счётчик будет равен кол-ву подстрок. Для оптимальной проверки данного факта будем сравнивать значения счётчиков с количеством подстрок при обновлении из последней подстроки (заметим, что индексы, являющихся ответами для всего паттерна, будут ответами и для каждой его подстроки, поэтому мы их обязательно рассмотрим) \
Чтобы быстро обнулять счётчики заведём для каждого индекса переменную, указывающую на последний запрос, в котором изменялся счётчик. Если это переменная отлична от текущего запроса, то принимаем счётчик равным нулю

# Асимптотическая оценка
Предподсчёт представляет из себя только построение суффиксного автомата, что требует O(n log E) действий, где E - размер алфавита, однако обычно он приравнивается к константе и мы можем считать асимптотику равной O(n) \
Для каждого запроса мы пройдёмся по каждой его подстроке, что суммарно даст не более длины паттерна, а также сделаем sum a_i обновлений счётчика, где a_i - ответ для i-ой подстроки, что несколько хуже требуемой асимптотике, но на реальных данных не очень далеко от оной
